<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Palindromic substrings</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="e07b35d7-59fc-477a-8580-704a264575e5" class="page sans"><header><h1 class="page-title">Palindromic substrings</h1></header><div class="page-body"><h1 id="a8c253c2-e01e-4828-b4ac-2707a7e9e2bd" class="">My code </h1><ul id="47cd8447-8d8c-4be4-b8f4-c12661d70704" class="bulleted-list"><li>out of time (works but not economic code)</li></ul><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="14bde081-416a-4931-9f6c-f6146039559d" class="code"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type s: str
        :rtype: int
        """</span>
        <span class="token comment">#input does not exceed 1000</span>
        <span class="token comment">#list substrings</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        subStringsList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                sub_string <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">==</span> j <span class="token keyword">else</span> s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                subStringsList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sub_string<span class="token punctuation">)</span>
                
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>subStringsList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            temp_string <span class="token operator">=</span> subStringsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            midIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp_string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>
            
            <span class="token keyword">if</span> midIndex <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>temp_string<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> temp_string<span class="token punctuation">[</span><span class="token punctuation">:</span>midIndex<span class="token punctuation">]</span><span class="token operator">==</span>temp_string<span class="token punctuation">[</span><span class="token operator">-</span>midIndex<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>temp_string<span class="token punctuation">)</span>
        <span class="token comment">#print(result)</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h1 id="14a5a195-50f8-47b2-8c29-a2f10d5b7313" class=""><strong>Solution</strong></h1><hr id="4081a90d-69d5-4729-919f-bc1719798ff1"/><h3 id="420212d1-ed9d-49fd-86ec-80824c9e681d" class=""><strong>A Brief Refresher</strong></h3><p id="9a15cd77-38bf-4278-8374-1286f7105de1" class=""><strong>What is a palindrome?</strong></p><p id="efb9cc80-88ff-4c10-8c2c-92d4d2e7333e" class="">A palindrome is a sequence of characters that read the same, forwards and backwards. If you tried reversing a palindrome, you wouldn&#x27;t see a change. For example, the string &quot;kayak&quot; is a palindrome, but the word &quot;livid&quot; isn&#x27;t one.</p><p id="60e230da-beb5-4dfb-9109-c45a98682681" class=""><strong>There are two types of palindromes...</strong></p><p id="82117a74-ce0b-4085-b1cf-7202136fa8e1" class="">Odd and even length palindromes!</p><p id="9de7ba67-4786-4848-b813-d6fd14673254" class="">Odd-length palindromes have a single character in the middle. e.g. &quot;civic&quot; with middle character &#x27;v&#x27;.</p><p id="46c8799e-e97a-40bd-b3d5-a134618605d9" class="">Even-length palindromes have two characters constitute the middle, both of which are same. e.g. &quot;noon&quot; with two middle characters &#x27;o&#x27;.</p><blockquote id="cd45965f-3199-4257-95fe-892a3401aa1e" class="">Pop Quiz: Is &quot;y&quot; a palindrome? Is &quot;gg&quot; a palindrome?</blockquote><p id="5335c4bb-6a11-4293-9737-f0513b9af0f0" class="">Yes, both of the above are palindromes. &quot;y&quot; is single letter (hence odd-length) palindrome whose middle is the single &#x27;y&#x27; character. &quot;gg&quot; is a double letter (hence even-length) palindrome whose middle is comprised of the two &#x27;g&#x27; characters.</p><p id="5d8d8cdd-8c3f-4d54-8942-bdec131eae47" class=""><strong>Palindromes are compositionally homogeneous around their center...</strong></p><p id="143b6280-452d-4b13-a1ab-d046d425e5de" class="">In layman&#x27;s terms, smaller palindromes make up larger palindromes. If you take the palindrome &quot;eve&quot; and surround it with the character &#x27;l&#x27;, you get a larger palindrome &quot;level&quot;. Conversely, if you removed the starting and ending characters from &quot;eve&#x27;, you&#x27;d be left with the smaller, single-character palindrome &quot;v&quot;.</p><hr id="05695e4e-9f6f-4f7c-902e-41e24385b851"/><h3 id="27e0a8ca-5c09-4c12-925b-69bab46f43e6" class=""><strong>Approach #1: Check All Substrings</strong></h3><p id="175aba05-5eaa-4f36-997c-88ddb5b22694" class=""><strong>Intuition</strong></p><p id="8d8cb14e-988e-4653-a0b1-33728f1d1628" class="">Just do what the question says! We look at all substrings of the input string and check if they are palindromes.</p><p id="ec77673a-64b6-4d1f-96bb-eba69fdc6f6d" class=""><strong>Algorithm</strong></p><p id="1ae80156-9a2c-4c23-8e6d-4589e3e602c9" class="">Each substring is denoted by a pair of variables pointing to the start and end indices of the sub-string.</p><blockquote id="b9223d4d-88ea-4959-acfd-7b9ca0764454" class="">A single character substring is denoted by start and end indices being equal in value.</blockquote><p id="8b6d54b3-1b1f-489f-9a84-63d952297a7c" class="">Checking for a palindrome is simple; we check if the ends of the substring are the same character, going outside-in:</p><ul id="19b5d8b4-b7d3-4eac-a8ea-9b0f81e7cf11" class="bulleted-list"><li>If they aren&#x27;t, this substring is not a palindrome.</li></ul><ul id="74c4f110-fe28-4d4c-a114-40d0070fba5d" class="bulleted-list"><li>Else, we continue checking inwards until we get to the middle.</li></ul><figure id="6a302aee-59bf-4e3d-b1e8-3c1b394fccd1"><div class="source"><a href="https://leetcode.com/playground/GWozeAqX/shared">https://leetcode.com/playground/GWozeAqX/shared</a></div></figure><p id="7edf6829-2956-42cc-b9ab-7d0a89954907" class=""><strong>Complexity Analysis</strong></p><ul id="5950a898-0602-4979-b2da-afd884624be5" class="bulleted-list"><li><mark class="highlight-yellow_background">Time Complexity: O(N^3)</mark><mark class="highlight-yellow_background"><em>O</em></mark><mark class="highlight-yellow_background">(</mark><mark class="highlight-yellow_background"><em>N</em></mark><mark class="highlight-yellow_background">3) for input string of length N</mark><mark class="highlight-yellow_background"><em>N</em></mark><mark class="highlight-yellow_background">.Since we just need to traverse every substring once, the total time taken is sum of the length of all substrings.</mark><p id="cd3db964-4bfe-4d8d-b424-628e1354d3a4" class="">In a string of length N<em>N</em>, then there are:</p><ul id="daf7e6fb-81d8-41a7-8d4e-a167443a22b1" class="bulleted-list"><li>N<em>N</em> substrings of size 1.<p id="d74671e6-3dcd-48df-b3f4-0614672a662c" class="">1</p></li></ul><ul id="80a2d8bd-52a7-4e7a-afd4-2d34cb9d6964" class="bulleted-list"><li>N-1<em>N</em>−1 substrings of size 2.<p id="dd562766-869e-4ead-a21d-5e6bbbf00c83" class="">2</p></li></ul><ul id="4d4f1a62-f2b5-47cc-9b46-a48bde5c2b80" class="bulleted-list"><li>N-3<em>N</em>−3 substrings of size 3.<p id="7bff5d3c-7d0d-428b-bcf7-8888cf4962e4" class="">3</p></li></ul><ul id="3b08ca9d-9260-4f5c-989e-bbd8a0435393" class="bulleted-list"><li>...</li></ul><ul id="800a11db-651f-4cbb-8fdb-147b99799c93" class="bulleted-list"><li>11 substring of size <em>N</em> (which is the entire string).<p id="691b054a-d790-4dfc-bf89-a4da0821beee" class="">N</p></li></ul><p id="6fb28bb8-63ab-4d03-908c-b98ecd303a1d" class="">Total time taken to traverse all of these strings is in the order of</p><p id="377df0eb-a660-4f36-a657-bec7f79654d5" class="">\begin{aligned} &amp;1 \cdot (N) + 2 \cdot (N-1) + 3 \cdot (N-2) + ... + N \cdot (1) \\ &amp;= N + 2(N-1) + 3(N-2) + ... + N(N - (N-1)) \\ &amp;= (N + 2N + 3N + ... + N^2) - (2 + (3 \times 2) + (4 \times 3) + ... + (N \times (N-1))) \\ &amp;= N \sum_{i = 1}^{N} i - \sum_{i=1}^{N} i \cdot (i-1) \\ \end{aligned}1⋅(<em>N</em>)+2⋅(<em>N</em>−1)+3⋅(<em>N</em>−2)+...+<em>N</em>⋅(1)=<em>N</em>+2(<em>N</em>−1)+3(<em>N</em>−2)+...+<em>N</em>(<em>N</em>−(<em>N</em>−1))=(<em>N</em>+2<em>N</em>+3<em>N</em>+...+<em>N</em>2)−(2+(3×2)+(4×3)+...+(<em>N</em>×(<em>N</em>−1)))=<em>N</em><em>i</em>=1∑<em>N</em><em>i</em>−<em>i</em>=1∑<em>N</em><em>i</em>⋅(<em>i</em>−1)</p><p id="498fd457-703e-4aae-8b2c-619458a09573" class="">The term \sum_{i=1}^{N} i \cdot (i-1)∑<em>i</em>=1<em>N</em><em>i</em>⋅(<em>i</em>−1) can we written as \sum_{i=1}^{N} i^2 - \sum_{i=1}^{N} i∑<em>i</em>=1<em>N</em><em>i</em>2−∑<em>i</em>=1<em>N</em><em>i</em>, which transforms the aforementioned expression to</p><p id="b66f4bec-898f-4c96-aa07-4612440ff563" class="">\begin{aligned} &amp;N \sum_{i = 1}^{N} i - \sum_{i=1}^{N} i^2 + \sum_{i=1}^{N} i \\ &amp;= (N+1) \sum_{i = 1}^{N} i - \sum_{i=1}^{N} i^2 \\ &amp;= \frac{N(N+1)^2}{2} - \frac{N(N+1)(2N+1)}{6} \\ &amp;= \frac{N(N+1)^2}{6} \simeq N^3 \end{aligned}<em>N</em><em>i</em>=1∑<em>N</em><em>i</em>−<em>i</em>=1∑<em>N</em><em>i</em>2+<em>i</em>=1∑<em>N</em><em>i</em>=(<em>N</em>+1)<em>i</em>=1∑<em>N</em><em>i</em>−<em>i</em>=1∑<em>N</em><em>i</em>2=2<em>N</em>(<em>N</em>+1)2−6<em>N</em>(<em>N</em>+1)(2<em>N</em>+1)=6<em>N</em>(<em>N</em>+1)2≃<em>N</em>3</p></li></ul><ul id="be81e7c3-7822-47a3-b7a2-00e19d3eaa9d" class="bulleted-list"><li>Space Complexity: O(1)<em>O</em>(1). We don&#x27;t need to allocate any extra space since we are repeatedly iterating on the input string itself.</li></ul><hr id="19dcfa99-6ae3-42ba-b4cb-3a5797d8cb0e"/><h3 id="9385e38b-37c7-4b09-af84-b9f9658b6dca" class=""><strong>Approach #2: Dynamic Programming</strong></h3><p id="d161d26a-c6a7-4655-894c-641eec528691" class=""><strong>Intuition</strong></p><p id="2e5199c5-4f73-4ff8-9467-d6eb2619204c" class=""><mark class="highlight-yellow_background"><a href="https://leetcode.com/problems/palindromic-substrings/solution/#approach-1-check-all-substrings">Approach #1</a></mark><mark class="highlight-yellow_background"> spent a lot of time checking if a particular substring is a palindrome. What if we could speed up this check, by say, reusing previously calculated results? </mark>Turns out that checking whether a string is a palindrome or not, is a good candidate for <mark class="highlight-red">dynamic programming!</mark></p><p id="a79d8e95-8ea3-46b1-8f21-5e148140ef45" class="">It displays the <em>two, </em><em><strong>necessary</strong></em><em> characteristics</em> of a dynamic programming problem:</p><ol id="81a63297-e737-4819-910c-d7604e0a98be" class="numbered-list" start="1"><li><strong>Optimal substructure</strong>: Remember that larger palindromes are made of smaller palindromes. Congratulation, we have discovered a substructure to our problem! Knowing that a string is made up of a palindrome <em>helps</em> us determine if the string itself is a palindrome.<p id="63651386-d728-4817-9eac-7e22443f41ff" class="">Here&#x27;s an example: for the string &quot;axbobxa&quot;, the first and the last characters match, so it&#x27;s a potential palindrome. <mark class="highlight-red">If we knew already that its substring &quot;xbobx&quot; is also a palindrome, there wouldn&#x27;t be a need for any further checks.</mark></p><blockquote id="e1fec8ea-bede-4fd1-a83f-361d624e5453" class="">But is this substructure optimal?</blockquote><p id="2c31982f-5fe8-46c3-a2fd-aef560059366" class="">Yes! Since the optimal result for a string relies only on the optimal result for just one subproblem, and has to do just one check for the boundary characters (in constant time), this is an optimal substructure. We cannot get this result by checking fewer than one subproblem (it wouldn&#x27;t be a substructure anymore) <em>or</em> doing the boundary characters check faster (it&#x27;s already constant time!).</p></li></ol><ol id="bca01a80-d63d-4141-bd5f-ed55fb106671" class="numbered-list" start="2"><li><strong>Overlapping sub-problems</strong>: While checking all substrings of a large string for palindromicity, we might need to check some smaller substrings for the same, repeatedly. If we store the result of processing those smaller substrings, we can reuse those while processing larger substrings.<p id="deccf068-d7ba-4506-9025-fd799bdfafb8" class="">Here&#x27;s an example: for the string &quot;axbobxa&quot;, the substring &quot;bob&quot; needs to checked for the substring &quot;xbobx&quot; and the string &quot;axbobxa&quot;. In fact, to check all three of these strings, the single character string &quot;o&quot; needs to be checked.</p></li></ol><p id="e367a94b-4696-4367-b0b5-4b8850a3a598" class=""><strong>Algorithm</strong></p><p id="40b90b79-5e0c-401a-bf9d-91bdf745d0d7" class="">Here&#x27;s the simple framework for our dynamic programming solution:</p><ol id="74be4440-30bb-44d5-ad1c-8bfa808d9075" class="numbered-list" start="1"><li>Define the dynamic programming <em>state</em>. This is the result that gets reused in further computations.<p id="e3e7d363-409d-4903-9398-9e543759cacb" class="">Let&#x27;s define our state \text{dp(i, j)}dp(i, j), which tells us whether the substring composed of the i^{th}<em>i</em><em>t</em><em>h</em> to the j^{th}<em>j</em><em>t</em><em>h</em> characters of the input string, is a palindrome or not.</p><p id="d882323f-891e-4537-a854-3bafdec435ec" class="">Thus, the answer to our problem lies in counting all substrings whose state is <em>true</em>.</p></li></ol><ol id="e6c91896-03d4-4666-a936-0ddcd01c2878" class="numbered-list" start="2"><li>Identify the <em>base cases</em>. There are essentially two base-cases:<ul id="bdec6739-4283-4355-9b7f-17cdebeda98d" class="bulleted-list"><li>Single letter substrings are palindromes by definition. i.e. <em>d</em><em>p</em>(<em>i</em>,<em>i</em>)=<em>t</em><em>r</em><em>u</em><em>e</em><p id="358383ed-8ca2-49a0-8c4d-9b1f844b2c3f" class="">dp(i, i) = true</p></li></ul><ul id="993b81ea-a176-4d95-a042-6cf793711649" class="bulleted-list"><li>Double letter substrings composed of the same character are palindromes. i.e. <em>d</em><em>p</em>(<em>i</em>,<em>i</em>+1)={<em>t</em><em>r</em><em>u</em><em>e</em><em>f</em><em>a</em><em>l</em><em>s</em><em>e</em>if <em>s</em><em>i</em>=<em>s</em><em>i</em>+1otherwise<p id="d438734e-4ac5-4d2f-a96c-5af5f20a875f" class="">dp(i,i+1) = \begin{cases} true &amp;\text{if \space \space} s_i = s_{i+1} \\ false &amp;\text{otherwise} \end{cases}</p></li></ul></li></ol><ol id="97a69482-dcac-4b2f-b3f1-1ccbbbf677bf" class="numbered-list" start="3"><li>Identify the <em>optimal substructure</em>. A string is considered a palindrome if:<ul id="7dc08d1e-23b7-4a2c-bd5d-31a3b1c11a3e" class="bulleted-list"><li>Its first and last characters are equal, and</li></ul><ul id="f1ca6f48-66e4-47e4-a5cc-3e3291e7e9d3" class="bulleted-list"><li>The rest of the string (excluding the boundary characters) is also a palindrome.</li></ul><p id="f0380677-14e5-44c1-a2d2-c1519a263a5f" class="">This optimal substructure can be formulated into a recurrence rule: dp(i,j) = \begin{cases} true &amp;\text{if \space \space} dp(i+1, j-1) \land (s_i = s_j) \\ false &amp;\text{otherwise} \end{cases}<em>d</em><em>p</em>(<em>i</em>,<em>j</em>)={<em>t</em><em>r</em><em>u</em><em>e</em><em>f</em><em>a</em><em>l</em><em>s</em><em>e</em>if   <em>d</em><em>p</em>(<em>i</em>+1,<em>j</em>−1)∧(<em>s</em><em>i</em>=<em>s</em><em>j</em>)otherwise</p></li></ol><ol id="da5dbc12-c14a-4e79-95e2-2d3b63419815" class="numbered-list" start="4"><li>Identify <em>overlapping sub-problems</em> and compute them only once. The optimal substructure mentioned above ensures that the state for a string depends only on the state for a single substring. If we compute (and save) the states for all smaller strings first, larger strings can be processed by reusing previously saved states. The base cases that we have identified already define states for single and double letter strings. We can use those to compute states for three character (and subsequently larger) strings.</li></ol><ol id="c8d86fa8-88e3-4fd5-acb9-d001a0bba2ed" class="numbered-list" start="5"><li>The answer is found by counting all states that evaluate <em>true</em>. Since each state tells whether a unique substring is a palindrome or not, counting <em>true</em> states provides us the number of palindromic substrings.</li></ol><figure id="73f1134d-b77e-4fae-a88d-02201efe447d"><div class="source"><a href="https://leetcode.com/playground/MHnhhUTP/shared">https://leetcode.com/playground/MHnhhUTP/shared</a></div></figure><p id="6af55a15-0436-4e1f-8610-5e1345c6ff78" class=""><strong>Complexity Analysis</strong></p><ul id="aa8a991e-93f5-4fdf-905a-f73611b24536" class="bulleted-list"><li>Time Complexity: O(N^2)<em>O</em>(<em>N</em>2) for input string of length N<em>N</em>. The number of dynamic programming states that need to calculated is the same as the number of substrings i.e. {N \choose 2} = N(N-1)/2(2<em>N</em>)=<em>N</em>(<em>N</em>−1)/2. Each state can be calculated in constant time using a previously calculated state. Thus overall time take in the order of O(N^2)<em>O</em>(<em>N</em>2).</li></ul><ul id="4e01c358-9c3c-4653-99fe-25ee7b861be2" class="bulleted-list"><li>Space Complexity: O(N^2)<em>O</em>(<em>N</em>2) for an input string of length N<em>N</em>. We need to allocate extra space to hold all N \choose 2(2<em>N</em>) dynamic programming states.</li></ul><blockquote id="e4e7a858-ab4f-4eb6-a338-7a85e6103396" class="">Pop Quiz: Can you reduce the space consumption of this approach to linear extra space (i.e. O(N)O(N))?</blockquote><p id="bbe0e8e8-089c-4bb7-982a-cef7df0da04d" class="">Yes, it&#x27;s possible! Notice that the states of a subsbtring of length n<em>n</em> actually rely only on states for substrings of length n-2<em>n</em>−2. Thus, we can choose to store only the states for substrings of length n-1<em>n</em>−1 and n-2<em>n</em>−2 for an iteration of susbtrings of length n<em>n</em>, which takes only O(N)<em>O</em>(<em>N</em>) extra space. All states older than those can be discarded in that iteration. The next approach builds on this insight.</p><hr id="5c470e05-5e72-4ff3-8281-26b938961048"/><h3 id="e6865edd-fd1d-4871-8344-6b9e2ebd8fa0" class=""><strong>Approach #3: Expand Around Possible Centers</strong></h3><p id="5ea42d64-df6c-4448-8df0-609fb9d17ca9" class=""><strong>Intuition</strong></p><blockquote id="42b789ee-6167-452a-ba70-83cacfe484d1" class="">Palindromes are like onions, you remove the boundary characters and you&#x27;re left with another, smaller palindrome.</blockquote><p id="85a34901-c8ea-446c-b76e-7649a5dbeb14" class="">Multiple palindromes have the same centers. If we choose a center, we can continue to expand around it as long as we can make larger and larger palindromes.</p><p id="472269eb-e062-4a26-9513-8ac1ffe96865" class="">Let&#x27;s take the string &quot;lever&quot; as an example: if you choose the character &#x27;v&#x27; as the center, one can see that the palindromes &quot;v&quot; and &quot;eve&quot; are possible. However, the final expansion &quot;lever&quot; is not a palindrome (the first and last characters don&#x27;t match).</p><p id="319e661e-44b1-4fa7-bf37-3551c204ed80" class=""><strong>Algorithm</strong></p><ol id="ec33c522-8168-41b7-87f1-b52ad028aa3c" class="numbered-list" start="1"><li>We choose all possible centers for potential palindromes:<ul id="cd7e6589-36ce-4888-8251-63e4a549913a" class="bulleted-list"><li>Every single character in the string is a center for possible odd-length palindromes</li></ul><ul id="2db41bd3-0c5b-43b3-8588-f1122d37d6b9" class="bulleted-list"><li>Every pair of consecutive characters in the string is a center for possible even-length palindromes.</li></ul></li></ol><ol id="c6fd7be5-429d-4ca7-872a-756f028b6aed" class="numbered-list" start="2"><li>For every center, we can expand around it as long as we get palindromes (i.e. the first and last characters should match).</li></ol><figure id="e626c4a8-f513-415a-9a48-2b39869ec28c"><div class="source"><a href="https://leetcode.com/playground/eWX8CGxX/shared">https://leetcode.com/playground/eWX8CGxX/shared</a></div></figure><p id="f5c5917e-ddc8-49e7-a38e-e2e6b27ea35d" class=""><strong>Complexity Analysis</strong></p><ul id="c7d309fa-8671-42d4-95ce-9b3f4be604fa" class="bulleted-list"><li>Time Complexity: O(N^2)<em>O</em>(<em>N</em>2) for input string of length N<em>N</em>. The total time taken in this approach is dictated by two variables:<ul id="a358f692-b320-4f55-a547-6f00170d98de" class="bulleted-list"><li>The number of possible palindromic centers we process.</li></ul><ul id="67066119-8317-407f-9f6a-b3fde23c6b0f" class="bulleted-list"><li>How much time we spend processing each center.</li></ul><p id="555c0ea7-00e5-45b8-82b5-5889d2566bbe" class="">The number of possible palindromic centers is 2N-12<em>N</em>−1: there are N<em>N</em> single character centers and N-1<em>N</em>−1 consecutive character pairs as centers.</p><p id="48dd5d2e-9e46-4580-8f21-6788c1f6d381" class="">Each center can potentially expand to the length of the string, so time spent on each center is linear on average. Thus total time spent is N \cdot (2N-1) \simeq N^2<em>N</em>⋅(2<em>N</em>−1)≃<em>N</em>2.</p></li></ul><ul id="959e9cd3-7e56-42ce-822f-de1642768ddb" class="bulleted-list"><li>Space Complexity: O(1)<em>O</em>(1). We don&#x27;t need to allocate any extra space since we are repeatedly iterating on the input string itself.</li></ul><hr id="094b7e48-0c0b-432f-ac23-88dda885507f"/><h3 id="a820b9d4-13b2-4ad1-852d-5840cddcb962" class=""><strong>Further Thoughts</strong></h3><p id="28b7cc3a-cd21-49be-bd63-692a2f4c3b70" class="">Better approaches do exist to solve this problem in sub-quadratic time, however those are significantly complex and impractical to implement in most interviews.</p><p id="bb6cf057-34b7-446f-83ef-fbcee03d1d0d" class="">Some known approaches are:</p><ol id="e64c2304-4538-404e-b217-0471728d7a4b" class="numbered-list" start="1"><li><strong>Binary Search with a fast rolling hash algorithm (like Rabin-Karp).</strong> This approach tries to optimize <a href="https://leetcode.com/problems/palindromic-substrings/solution/#approach-3-expand-around-possible-centers">Approach #3</a> by speeding up the time to figure out the largest palindrome for each of the 2N-12<em>N</em>−1 centers in logarithmic time. This approach counts all palindromic substrings in O(N \log{N})<em>O</em>(<em>N</em>log<em>N</em>) time. <a href="https://qr.ae/pNkBDo">Here&#x27;s a Quora answer by T.V. Raziman</a> which explains this approach well.</li></ol><ol id="07564e10-878f-4914-b23e-657f950da90f" class="numbered-list" start="2"><li><strong>Palindromic trees (also known as </strong><a href="https://arxiv.org/abs/1506.04862"><strong>EERTREE</strong></a><strong>).</strong> It is a data structure invented by Mikhail Rubinchik which links progressively larger palindromic substrings within a string. The tree construction takes linear time, and the number of palindromic substrings can be counted while constructing the tree in O(N)<em>O</em>(<em>N</em>) time. Additionally, the tree can be used to compute how many distinct palindromic substrings are in a string (it&#x27;s just the number of nodes in the tree) and how frequently each such palindrome occurs. <a href="http://adilet.org/blog/palindromic-tree/https://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b">This blog post</a> does a good job of explaining the construction of a palindromic tree.</li></ol><ol id="18092364-a7f2-4900-80c9-1dbb021135a5" class="numbered-list" start="3"><li><strong>Suffix Arrays with quick Lowest common Ancestor (LCA) lookups.</strong> This approach utilizes Ukonnen&#x27;s algorithm to build suffix trees for the input string and its reverse in linear time. Subsequently, quick LCA lookups can be used to find maximum palindromes, which are themselves composed of smaller palindromes. This approach can produce a count of all palindromic substrings in O(N)<em>O</em>(<em>N</em>) time. <a href="http://par.cse.nsysu.edu.tw/~algo/paper/paper06/A24.pdf">The original paper</a> describes the algorithm, and <a href="https://qr.ae/pNkEWR">this Quora answer</a> demonstrates an example.</li></ol><ol id="74df7972-c7bb-4104-890d-c2ffcbbe68ba" class="numbered-list" start="4"><li><strong>Manacher&#x27;s algorithm.</strong> <em>It&#x27;s basically </em><a href="https://leetcode.com/problems/palindromic-substrings/solution/#approach-3-expand-around-possible-centers"><em>Approach #3</em></a><em>, on steroids.</em>TM The algorithm reuses computations done for previous palindromic centers to process new centers in sub-linear time (which reduces progressively for each new center). This algorithm counts all palindromic substrings in O(N)<em>O</em>(<em>N</em>) time. <a href="https://cp-algorithms.com/string/manacher.html">This e-maxx post</a> provides a fairly simple implementation of this algorithm.</li></ol></div></article></body></html>