<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Sorting Algorithms</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="e4511261-d67e-4ec0-8344-33445c5be38b" class="page sans"><header><h1 class="page-title">Sorting Algorithms</h1></header><div class="page-body"><p id="0e4e77fd-0f1c-442d-8913-6b5e275b0a48" class=""><a href="https://lamfo-unb.github.io/2019/04/21/Sorting-algorithms/">https://lamfo-unb.github.io/2019/04/21/Sorting-algorithms/</a></p><h1 id="475a8e0e-caab-4ff6-b3da-caa6085b59ba" class=""><strong>What are Sorting Algorithms?</strong></h1><p id="81a97867-9d8d-43e9-838b-d618372b2b2c" class="">Sorting algorithms are <mark class="highlight-yellow_background">ways to organize an array of items from smallest to largest. </mark>These algorithms can be used to organize messy data and make it easier to use. Furthermore, having an understanding of these algorithms and how they work is fundamental for a strong understanding of Computer Science which is becoming more and more critical in a world of premade packages. This blog focuses on the speed, uses, advantages, and disadvantages of specific Sorting Algorithms.</p><p id="4ce556ca-33ae-47f2-acde-1ff6aec79235" class="">Although there is a wide variety of sorting algorithms, this blog explains Straight Insertion, <mark class="highlight-yellow_background">Shell Sort, Bubble Sort, Quick Sort, Selection Sort, and Heap Sort. </mark>The first two algorithms (Straight Insertion and Shell Sort) sort arrays with insertion, which is when elements get inserted into the right place. The next 2 (Bubble Sort and Quick Sort) sort arrays with exchanging which is when elements move around the array. The last one is heap sort which sorts through selection where the right elements are selected as the algorithm runs down the array.</p><h1 id="0aa799de-7363-4263-ba66-12eee825aca1" class=""><strong>Big-O Notation</strong></h1><p id="989bd29c-5c03-45ba-9fa5-2678f3a25fe3" class="">Before this blog goes any further, it is essential to explain the methods that professionals use to <mark class="highlight-yellow_background">analyze and assess algorithm complexity and performance.</mark> The current standard is called “Big O notation” named according to its notation which is an “O” followed by a function such as “O(n).”</p><h1 id="ad4661f0-5615-4073-9634-1de65b8cd40a" class=""><strong>Formal definition</strong></h1><blockquote id="c7d9ec6f-8b4f-4ccd-9278-3e80c98b8bce" class="">Suppose f(x) and g(x) are two functions defined on some subset of the real numbers. We write f(x) = O(g(x)) (or f(x) = O(g(x)) for x -&gt; ∞ to be more precise) if and only if there exist constants N and C such that |f(x)| &lt;= C |g(x)| for all x&gt;N. Intuitively, this means that f does not grow faster than g.</blockquote><p id="007dd0ff-0cff-4831-a3e8-ab9b114aae76" class=""><mark class="highlight-yellow_background">Big O is used to denote either the time complexity of an algorithm or how much space it takes up</mark>. This blog focuses mainly on the time complexity part of this notation. The way people can calculate this is by identifying the worst case for the targeted algorithm and formulating a function of its performance given an n amount of elements. For example, if there were an algorithm that searched for the number 2 in an array, then the worst case would be if the 2 was at the very end of the array. <mark class="highlight-yellow_background">Therefore, the Big O notation would be O(n) since it would have to run through the entire n-element array before finding the number 2.</mark></p><p id="8e416863-cb8e-468d-80d3-825ce611d0d2" class="">
</p><p id="25daf1ea-dcf9-4f8d-8682-17167330a9b6" class="">To help you, find below a table with algorithms and its complexity.</p><figure id="0c3bb7e8-a9f2-4b6d-a53b-a1dad9615592" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Complexity.png"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Complexity.png"/></a></figure><h1 id="b2d39552-ff8b-49df-bf48-d982e3e60fbe" class=""><strong>Straight Insertion Sort</strong></h1><figure id="cccb2643-efa5-4dc3-b41b-63912b4def7d" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Insertion_sort_animation.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Insertion_sort_animation.gif"/></a></figure><p id="3a91ac59-8e0c-42b8-9469-e88d6a359cfb" class="">Straight insertion sort is one of the most basic sorting algorithms that essentially inserts an element into the right position of an already sorted list. It is usually added at the end of a new array and moves down until it finds an element smaller thank itself (the desired position). The process repeats for all the elements in the unsorted array. Consider the array {3,1,2,5,4}, we begin at 3, and since there are no other elements in the sorted array, the sorted array becomes just {3}. Afterward, we insert 1 which is smaller than 3, so it would move in front of 3 making the array {1,3}. This same process is repeated down the line until we get the array {1,2,3,4,5}.</p><p id="10061bb3-5bf4-4d2c-a5a8-fa0adbd50621" class="">
</p><figure id="cc6099d4-8276-45d0-a39b-31947976ddfa" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Insertion-sort-example-300px.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Insertion-sort-example-300px.gif"/></a></figure><p id="767846af-455b-4319-acb9-7e1a06cc1062" class="">The advantages of this process are that it is straightforward and easy to implement. Also, it is relatively quick when there are small amounts of elements to sort. It can also turn into binary insertion which is when you compare over longer distances and narrow it down to the right spot instead of comparing against every single element before the right place. However, a straight insertion sort is usually slow whenever the list becomes large.</p><p id="b4a078a4-f7ed-4070-a741-8307363b7073" class="">Main Characteristics:</p><ul id="77e17151-fa4c-4be6-ad4a-613139e024a2" class="bulleted-list"><li>Insertion sort family</li></ul><ul id="0a398491-c463-463e-b91f-944c301ed206" class="bulleted-list"><li>Straightforward and simple</li></ul><ul id="e33465de-0443-46db-883b-777700be50aa" class="bulleted-list"><li>Worst case = O(n^2)</li></ul><h3 id="f872778b-047d-492a-92a3-baaa84c04be9" class="">Python implementation</h3><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="3ff79975-0cbf-4047-abef-475b7e825c88" class="code"><code><span class="token triple-quoted-string string">''' by Minjoo '''</span>

<span class="token keyword">def</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        curVal <span class="token operator">=</span> alist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        curPos <span class="token operator">=</span> i
        
        <span class="token keyword">while</span> curPos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> alist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> curVal<span class="token punctuation">:</span>
                <span class="token comment">#insert value</span>
                alist<span class="token punctuation">[</span>curPos<span class="token punctuation">]</span><span class="token punctuation">,</span> alist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> alist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> alist<span class="token punctuation">[</span>curPos<span class="token punctuation">]</span>
            curPos <span class="token operator">=</span> curPos <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span>
        
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
    insertSort<span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><p id="1e0d4f69-00c2-423a-8da8-fe5cda5fb1cc" class="">
</p><h1 id="de039690-075a-4a43-b2c9-df2f9bc92d1b" class=""><strong>Shell Sort</strong></h1><figure id="19b73b8a-aec2-4fda-970f-a10104d8143a" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_shellsort_anim.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_shellsort_anim.gif"/></a></figure><p id="0c21e08f-a299-4868-b4a3-b498d4af078e" class="">Shell sort is an insertion sort that first partially sorts its data and then finishes the sort by running an insertion sort algorithm on the entire array. I<mark class="highlight-yellow_background">t generally starts by choosing small subsets of the array and sorting those arrays. Afterward, it repeats the same process with larger subsets until it reaches a point where the subset is the array</mark>, <mark class="highlight-yellow_background">and the entire thing becomes sorted.</mark> The advantage of doing this is that having the array almost entirely sorted helps the final insertion sort achieve or be close to its most efficient scenario.</p><figure id="7cc24b93-44b3-47e8-ad6e-45a5df2bedcb" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Shell_Sort_Algorithm.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Shell_Sort_Algorithm.gif"/></a></figure><p id="b986e004-54d0-48d4-b13a-75db8796a48f" class="">Furthermore, increasing the size of the subsets is achieved through a decreasing increment term. The increment term essentially chooses every kth element to put into the subset. It starts large, leading to smaller (more spread out) groups, and it becomes smaller until it becomes 1 (all of the array).</p><p id="7758d350-6bf8-437f-af4b-b03cb34c456e" class=""><mark class="highlight-yellow_background">The main advantage of this sorting algorithm is that it is more efficient than a regular insertion sort. Also, there is a variety of different algorithms that seek to optimize shell sort by changing the way the increment decreases since the only restriction is that the last term in the sequence of increments is 1.</mark> The most popular is usually Knuth’s method which uses the formula h=((3^k)-1)/2 giving us a sequence of intervals of 1 (k=1),4 (k=2),13 (k=3), and so on. On the other hand, shell sort is not as efficient as other sorting algorithms such as quicksort and merge sort.</p><p id="26aa297a-831f-4853-8824-1a62d8286fc2" class="block-color-yellow_background">Main Characteristics:</p><ul id="7709b0a7-1216-4ab8-8d6c-8bcbff53ee0d" class="block-color-yellow_background bulleted-list"><li>Sorting by insertion</li></ul><ul id="a7273f45-f876-452a-819b-b044e7d00923" class="block-color-yellow_background bulleted-list"><li>Can optimize algorithm by changing increments</li></ul><ul id="f0a7a6ed-048b-40c5-b65a-ce9a72845871" class="block-color-yellow_background bulleted-list"><li>Using Knuth’s method, the worst case is O(n^(3/2))</li></ul><p id="67370e5f-d3ce-4f43-8fb0-81b29ea8be7e" class="">Python implementation:</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="0623a533-008d-4624-9afe-4f2a91874c36" class="code"><code><span class="token keyword">def</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token punctuation">:</span>
    sublistcount <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span> <span class="token comment">#remove fractional operator (ignore)</span>
    <span class="token comment">#print(sublistcount)</span>
    <span class="token keyword">while</span> sublistcount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> start_position <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>sublistcount<span class="token punctuation">)</span><span class="token punctuation">:</span>
            gapInsertSort<span class="token punctuation">(</span>alist<span class="token punctuation">,</span>start_position<span class="token punctuation">,</span> sublistcount<span class="token punctuation">)</span>
        sublistcount <span class="token operator">=</span> sublistcount<span class="token operator">//</span><span class="token number">2</span>

<span class="token keyword">def</span> <span class="token function">gapInsertSort</span><span class="token punctuation">(</span>nlist<span class="token punctuation">,</span> start<span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>start<span class="token operator">+</span>steps<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nlist<span class="token punctuation">)</span><span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment">#(start, end, steps)</span>
        curVal <span class="token operator">=</span> nlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        curPos <span class="token operator">=</span> i
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"i:{}, val:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> nlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        
        <span class="token keyword">while</span> curPos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> nlist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> curVal<span class="token punctuation">:</span>
                <span class="token comment">#insert value</span>
                nlist<span class="token punctuation">[</span>curPos<span class="token punctuation">]</span><span class="token punctuation">,</span> nlist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nlist<span class="token punctuation">[</span>curPos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nlist<span class="token punctuation">[</span>curPos<span class="token punctuation">]</span>
            curPos <span class="token operator">=</span> curPos <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>nlist<span class="token punctuation">)</span>

        
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
    shellSort<span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><h1 id="593bf1f0-96cb-46f1-81bc-d73742a512c7" class=""><strong>Bubble Sort</strong></h1><figure id="af783f18-2f22-4a13-b2ed-dd246db7a1d0" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_bubblesort_anim.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_bubblesort_anim.gif"/></a></figure><p id="d1fcfbdc-20b6-44f9-b33c-e908b77cd57a" class="">Bubble sort compares adjacent elements of an array and organizes those elements. Its name comes from the fact that large numbers tend to “float” (bubble) to the top. It loops through an array and sees if the number at one position is greater than the number in the following position which would result in the number moving up. This cycle repeats until the algorithm has gone through the array without having to change the order. This method is advantageous because it is simple and works very well for mostly sorted lists. As a result, programmers can quickly and easily implement this sorting algorithm.<mark class="highlight-yellow_background"> However, the tradeoff is that this is one of the slower sorting algorithms.</mark></p><p id="54e569db-9775-4a1d-8ee8-88efb044ccbe" class=""><mark class="highlight-yellow_background">Main Characteristics: Exchange sorting Easy to implement Worst Case = O(n^2)</mark></p><p id="4befaf7e-3abd-4c6b-80ba-9d6a307257fa" class="">Python implementation:</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="2419d927-eff5-455e-be4f-e010b0309f64" class="code"><code><span class="token comment">#compares adjacent values#</span>
<span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment">#decrease in values</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> alist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> alist<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                alist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> alist<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> alist<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> alist<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>alist<span class="token punctuation">)</span>
                
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
    bubbleSort<span class="token punctuation">(</span>a<span class="token punctuation">)</span></code></pre><h1 id="cff710c9-e042-4663-8988-4a9582c9b96a" class=""><strong>Quicksort</strong></h1><figure id="b3e7f819-a9c0-42bc-af8d-23ac9d46b1e3" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Quicksort.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Quicksort.gif"/></a></figure><p id="983c198c-62f5-4009-bc93-9fbe46829157" class="">Quicksort is one of the most efficient sorting algorithms, and this makes of it one of the most used as well. <mark class="highlight-yellow_background">The first thing to do is to select a pivot number, this number will separate the data, on its left are the numbers smaller than it and the greater numbers on the right.</mark> With this, we got the whole sequence partitioned. After the data is partitioned, we can assure that the partitions are oriented, we know that we have bigger values on the right and smaller values on the left. <mark class="highlight-yellow_background">The quicksort uses this divide and conquer algorithm with recursion.</mark> So, now that we have the data divided we use recursion to call the same method and pass the left half of the data, and after the right half to keep separating and ordinating the data. At the end of the execution, we will have the data all sorted.</p><p id="6a48a5c2-2791-41b3-9e0d-4829c6622bd8" class="">Main characteristics:</p><ul id="6f8a9292-3655-4ae5-8ae0-9412a6bd6605" class="bulleted-list"><li>From the family of Exchange Sort Algorithms</li></ul><ul id="951fb5f8-0398-4c0a-ad2c-e1fb43e98946" class="bulleted-list"><li>Divide and conquer paradigm</li></ul><ul id="55636023-8c25-42ea-88c6-6258e50eb63e" class="bulleted-list"><li>Worst case complexity O(n²)</li></ul><figure id="93919918-70ef-4be3-8f6d-0f1ee39a1097" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Quicksort-example.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Quicksort-example.gif"/></a></figure><p id="72faeb10-1183-48ce-840d-71826ad28d8c" class="">
</p><h3 id="5e01bda2-13af-4ad2-8558-bd9ac3a4f61b" class=""><strong>How Quicksort Works</strong></h3><p id="616fef94-b45f-40c4-a9f0-891a61f3fb5a" class="">Quicksort will, more often than not, fail to divide the array into equal parts. This is because the whole process depends on how we choose the pivot. We need to choose a pivot so that it&#x27;s roughly larger than half of the elements, and therefore roughly smaller than the other half of the elements. As intuitive as this process may seem, it&#x27;s very hard to do.</p><p id="5b505d38-f15c-4b7f-9b7b-f2829e22750c" class="">Think about it for a moment - how would you choose an adequate pivot for your array? A lot of ideas about how to choose a pivot have been presented in Quicksort&#x27;s history - randomly choosing an element, which doesn&#x27;t work because of how &quot;expensive&quot; choosing a random element is while not guaranteeing a good pivot choice; picking an element from the middle; picking a median of the first, middle and last element; and even more complicated recursive formulas.</p><p id="2a00bab7-404d-495b-b2f2-e45a55e7350e" class="">The most straight-forward approach is to simply choose the first (or last) element. This leads to Quicksort, ironically, performing very badly on already sorted (or almost sorted) arrays.</p><p id="c094feef-a863-4056-b151-fbdd088c4c2b" class="">This is how most people choose to implement Quicksort and, since it&#x27;s simple and this way of choosing the pivot is a very efficient operation (and we&#x27;ll need to do it repeatedly), this is exactly what we will do.</p><p id="3cff44ea-1774-4829-a7c8-d57f36d2e807" class="">Now that we have chosen a pivot - what do we do with it? Again, there are several ways of going about the partitioning itself. We will have a &quot;pointer&quot; to our pivot, and a pointer to the &quot;smaller&quot; elements and a pointer to the &quot;larger&quot; elements.</p><p id="fadc3708-fbca-46dc-be87-3ab320495887" class="">The goal is to move the elements around so that all elements smaller than the pivot are to its left, and all larger elements are to its right. The smaller and larger elements don&#x27;t necessarily end up sorted, we <em>just</em> want them on the proper side of the pivot. We then recursively go through the left and right side of the pivot.</p><p id="e422de92-f1fc-41b8-8ccc-c52ee809d99b" class="">A step by step look at what we&#x27;re planning to do will help illustrate the process. Using the array shown below, we&#x27;ve chosen the first element as the pivot (29), and the pointer to the smaller elements (called &quot;low&quot;) starts right after, and the pointer to the larger elements (called &quot;high&quot;) starts at the end.</p><ul id="42d965e5-ef07-4ac1-8b7f-a8192c218e3c" class="bulleted-list"><li><em>29</em> is the first pivot, <em>low</em> points to <em>99</em> and <em>high</em> points to <em>44</em></li></ul><p id="c675910b-6ec9-4e84-b79c-648837001e90" class="">29 | <strong>99 (low)</strong>,27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,21,<strong>44 (high)</strong></p><ul id="10baa149-73b4-498b-b818-ec991c2e1631" class="bulleted-list"><li>We move <code>high</code> to the left until we find a value that&#x27;s lower than our pivot.</li></ul><p id="e580a682-2c2b-4930-8f7f-11b672a19d65" class="">29 | <strong>99 (low)</strong>,27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,<strong>21 (high)</strong>,44</p><p id="506b6d4c-05dd-4562-8b30-6aaae28403d2" class="">
</p><ul id="45c45329-6f3b-4332-917d-1960571534f6" class="bulleted-list"><li>Now that our <em>high</em> variable is pointing to <em>21</em>, an element smaller than the pivot, we want to find a value near the beginning of the array that we can swap it with. It doesn&#x27;t make any sense to swap with a value that&#x27;s also smaller than the pivot, so if <em>low</em> is pointing to a smaller element we try and find one that&#x27;s larger.</li></ul><ul id="0d020e0f-881d-4cc9-ab03-d8613aa9a2f1" class="bulleted-list"><li>We move our <em>low</em> variable to the right until we find an element larger than the <em>pivot</em>. Luckily, <em>low</em> was already positioned on <em>99</em>.</li></ul><ul id="cb677bac-8f59-4340-819c-be111e9ed5cf" class="bulleted-list"><li>We swap places of <em>low</em> and <em>high</em>:</li></ul><p id="26d871a2-1767-47d5-aa71-e8a057be450d" class="">29 | <strong>21 (low)</strong>,27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,<strong>99 (high)</strong>,44</p><ul id="a6382885-48a2-41e3-bb4a-360674f6ac1e" class="bulleted-list"><li>Right after we do this, we move <em>high</em> to the left and <em>low</em> to the right (since <em>21</em> and <em>99</em> are now in their correct places)</li></ul><ul id="7590a869-65f1-4091-a42c-ef4c7bea6380" class="bulleted-list"><li>Again, we move <em>high</em> to the left until we reach a value lower than the <em>pivot</em>, which we find right away - <em>12</em></li></ul><ul id="cdadd5f1-9906-4cd6-9cb1-99721ab22914" class="bulleted-list"><li>Now we search for a value larger than the <em>pivot</em> by moving <em>low</em> to the right, and we find the first such value at <em>41</em></li></ul><p id="a9be06ac-c5ec-4b82-b939-43ad48aa3240" class="">This process is continued until the <em>low</em> and <em>high</em> pointers finally meet in a single element:</p><p id="feb26322-6bce-4306-834f-56932b1214f7" class="">29 | 21,27,12,19,<strong>28 (low/high)</strong>,44,78,87,66,31,76,58,88,83,97,41,99,44</p><ul id="04b80a20-32a1-4a01-8fd9-a1cceb879fb4" class="bulleted-list"><li>We&#x27;ve got no more use of this pivot so the only thing left to do is to swap <em>pivot</em> and <em>high</em> and we&#x27;re done with this recursive step:</li></ul><p id="c8cc665f-0004-42a6-9c05-da09aad75dc3" class=""><strong>28</strong>,21,27,12,19,<strong>29</strong>,44,78,87,66,31,76,58,88,83,97,41,99,44</p><p id="500916fe-5b7a-43c6-a8bb-5e5a9c3b36ef" class="">As you can see, we have achieved that all values smaller than <em>29</em> are now to the left of <em>29</em>, and all values larger than <em>29</em> are to the right.</p><p id="85ec1fd2-88f4-4e82-86ad-248f45e49eb9" class="">The algorithm then does the same thing for the <em>28,21,27,12,19</em> (left side) collection and the <em>44,78,87,66,31,76,58,88,83,97,41,99,44</em> (right side) collection.</p><p id="edbc6204-4bd8-4d38-890b-bf0ff397399b" class="">Python implementation:</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="8cd99004-a53f-4175-80f3-70b676cd5246" class="code"><code><span class="token comment"># Python program for implementation of Quicksort Sort </span>
  
<span class="token comment"># This function takes last element as pivot, places </span>
<span class="token comment"># the pivot element at its correct position in sorted </span>
<span class="token comment"># array, and places all smaller (smaller than pivot) </span>
<span class="token comment"># to left of pivot and all greater elements to right </span>
<span class="token comment"># of pivot </span>
  
  
<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span>
    low <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span>
    high <span class="token operator">=</span> end

    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token comment"># If the current value we're looking at is larger than the pivot</span>
        <span class="token comment"># it's in the right place (right side of pivot) and we can move left,</span>
        <span class="token comment"># to the next element.</span>
        <span class="token comment"># We also need to make sure we haven't surpassed the low pointer, since that</span>
        <span class="token comment"># indicates we have already moved all the elements to their correct side of the pivot</span>
        <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high <span class="token keyword">and</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">:</span>
            high <span class="token operator">=</span> high <span class="token operator">-</span> <span class="token number">1</span>

        <span class="token comment"># Opposite process of the one above</span>
        <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high <span class="token keyword">and</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>
            low <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token number">1</span>

        <span class="token comment"># We either found a value for both high and low that is out of order</span>
        <span class="token comment"># or low is higher than high, in which case we exit the loop</span>
        <span class="token keyword">if</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>
            array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span>
            <span class="token comment"># The loop continues</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># We exit out of the loop</span>
            <span class="token keyword">break</span>

    array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span>

    <span class="token keyword">return</span> high
  
<span class="token comment"># The main function that implements QuickSort </span>
<span class="token comment"># arr[] --> Array to be sorted, </span>
<span class="token comment"># low  --> Starting index, </span>
<span class="token comment"># high  --> Ending index </span>
  
<span class="token comment"># Function to do Quick sort </span>
  
  
<span class="token keyword">def</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span> 
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> 
        <span class="token keyword">return</span> arr 
    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span> 
  
        <span class="token comment"># pi is partitioning index, arr[p] is now </span>
        <span class="token comment"># at right place </span>
        pi <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span> 
  
        <span class="token comment"># Separately sort elements before </span>
        <span class="token comment"># partition and after partition </span>
        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span> 
  
  
<span class="token comment"># Driver code to test above </span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> 
n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> 
quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Sorted array is:"</span><span class="token punctuation">)</span> 
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span> 
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
  
<span class="token comment"># This code is contributed by Mohit Kumra</span></code></pre><h1 id="128bf4ea-7aa0-4396-8c1a-8baa878d83cb" class=""><strong>Heapsort</strong></h1><figure id="5c691a9c-b389-4c69-9681-99b5ff40818c" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_heapsort_anim.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/Sorting_heapsort_anim.gif"/></a></figure><p id="fd3cb27f-d51c-4899-a21d-3bd541969475" class="">Heapsort is a sorting algorithm based in the structure of a heap. <mark class="highlight-yellow_background">The heap is a specialized data structure found in a tree or a vector.</mark> In the first stage of the algorithm, a tree is created with the values to be sorted, starting from the left, we create the root node, with the first value. Now we create a left child node and insert the next value, at this moment we evaluate if the value set to the child node is bigger than the value at the root node, if yes, we change the values. We do this to all the tree. The initial idea is that the parent nodes always have bigger values than the child nodes.</p><p id="67c9603d-4558-4ca3-97f8-c50e62ab0fbe" class="">At the end of the first step, we create a vector starting with the root value and walking from left to right filling the vector.</p><p id="7b976661-e658-41b2-ae77-d8b8b4700731" class="">Now we start to compare parent and child nodes values looking for the biggest value between them, and when we find it, we change places reordering the values. In the first step, we compare the root node with the last leaf in the tree. If the root node is bigger, then we change the values and continue to repeat the process until the last leaf is the larger value. When there are no more values to rearrange, we add the last leaf to the vector and restart the process. We can see this in the image below.</p><figure id="2d03f8ab-5061-49f1-b849-5589185d0da5" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/uv9rgMfetq-heapsort-example.gif"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/uv9rgMfetq-heapsort-example.gif"/></a></figure><p id="ae89408b-1587-4632-9a64-3a0eaf7ade36" class="">The main characteristics of the algorithm are:</p><ul id="dfeefd91-9b6d-4db6-8ba4-55d3342e09ce" class="bulleted-list"><li>From the family of sorting by selection</li></ul><ul id="6f37d38d-92ea-4e0e-a00f-2b2a8e4d0b17" class="bulleted-list"><li>Comparisons in the worst case = O(n log n)</li></ul><ul id="42aabe1a-f8f1-4af3-b49d-28ca148d2ffa" class="bulleted-list"><li>Not stable</li></ul><p id="fa93ae2e-9b38-4395-b250-81df3cb0dbef" class="">Python implementation:</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="780bdc80-1b8b-4ac4-abd4-49d615e2b86e" class="code"><code><span class="token comment">#!/usr/bin/env python3</span>
<span class="token comment"># -*- coding: utf-8 -*-</span>
<span class="token triple-quoted-string string">"""
Created on Sun Mar 10 18:18:25 2019

@source: https://www.geeksforgeeks.org/heap-sort/

"""</span>
<span class="token comment"># Python program for implementation of heap Sort </span>

<span class="token comment"># To heapify subtree rooted at index i. </span>
<span class="token comment"># n is size of heap </span>
<span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span> 
	largest <span class="token operator">=</span> i <span class="token comment"># Initialize largest as root </span>
	l <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span>	 <span class="token comment"># left = 2*i + 1 </span>
	r <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span>	 <span class="token comment"># right = 2*i + 2 </span>

	<span class="token comment"># See if left child of root exists and is </span>
	<span class="token comment"># greater than root </span>
	<span class="token keyword">if</span> l <span class="token operator">&lt;</span> n <span class="token keyword">and</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span> 
		largest <span class="token operator">=</span> l 

	<span class="token comment"># See if right child of root exists and is </span>
	<span class="token comment"># greater than root </span>
	<span class="token keyword">if</span> r <span class="token operator">&lt;</span> n <span class="token keyword">and</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span> 
		largest <span class="token operator">=</span> r 

	<span class="token comment"># Change root, if needed </span>
	<span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span> 
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment"># swap </span>

		<span class="token comment"># Heapify the root. </span>
		heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span> 

<span class="token comment"># The main function to sort an array of given size </span>
<span class="token keyword">def</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span> 
	n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> 

	<span class="token comment"># Build a maxheap. </span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
		heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span> 

	<span class="token comment"># One by one extract elements </span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment"># swap </span>
		heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> 

heapSort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span></code></pre><h1 id="c52ce2cb-5aae-42c5-977d-543b22df5c4f" class=""><strong>Benchmark: How fast they are?</strong></h1><p id="24f0e37e-e3fb-48f0-bfa2-9a246d73834f" class="">After development of the algorithms it is good for us to test how fast they can be. In this part we developed a simple program using the code above to generate a basic benchmark, just to see how much time they can use to sort a list of integers. Important observations about the code:</p><ul id="d7a62478-520a-4aa7-9ffe-6fa412719889" class="bulleted-list"><li>Python default recursion call limit is 1,000, in this test we are using big numbers, so we needed to improve that number to run the benchmark without errors. The limit was set to 10,000.</li></ul><ul id="1adab886-89b9-465d-b7ec-01139dd1f9a2" class="bulleted-list"><li>This code just measure the running time of each algorithm.</li></ul><ul id="3b2dad1d-eff0-4c08-acd6-51373041b992" class="bulleted-list"><li>It was made 20 tests with different size of lists ranging from 2500 to 50000.</li></ul><ul id="2651a969-677d-43a0-b377-91b6933606df" class="bulleted-list"><li>The numbers were generate randonly ranging from 1 to 10000. The results are the following: Shell sort and Heap Sort algorithms performed well despite the length of the lists, in the other side we found that Insertion sort and Bubble sort algorithms were far the worse, increasing largely the computing time. See the results in the chart below.</li></ul><figure id="7790ca25-a940-4c10-a35b-be667bc85783" class="image"><a href="https://lamfo-unb.github.io/img/Sorting-algorithms/benchmarkChart.png"><img src="https://lamfo-unb.github.io/img/Sorting-algorithms/benchmarkChart.png"/></a></figure><h1 id="64cbfcc3-4cee-4c0b-8efd-52e4b82012c2" class=""><strong>Conclusion</strong></h1><p id="945a4809-3213-466f-8e0b-97e67794b23e" class="">In this post, we showed 5 of the most common sorting algorithms used today. Before using any of them is extremely important to know how fast it runs and how much space is going to use. So it’s the tradeoff between complexity, speed, and volume. Another critical characteristic of the sorting algorithms that are important to know is its stability. The stability means that the algorithm keeps the order of elements with equal key values. The best algorithm changes for each different set of data and as a result, understanding our data plays a significant role in the process of choosing the right algorithm.</p></div></article></body></html>